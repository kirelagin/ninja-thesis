Виртуальная машина Dalvik
--------------------------

_Dalvik_ — виртуальная машина (ВМ), отвечающая за запуск Java-программ в Android. Это важная часть
ОС, поскольку многие системные сервисы, как и приложения, написаны на языке Java. В целях
безопасности каждое приложение запускается в отдельном процессе с собственным экземпляром виртуальной машины, потому
Dalvik был спроектирован таким образом, чтобы в системе могли работать несколько экземпляров ВМ,
расходуя ресурсы эффективно.

Исполняемые файлы приложений имеют расширение `.dex` (в отличие от традиционного для Java `.jar`) и
называются DEX[^dex]-файлами. Их формат оптимизирован для мобильных устройств, имеющих, по сравнению
с настольными компьютерами, меньший объем оперативной памяти и места для хранения данных, более
слабые процессоры. В результате оптимизации `.dex`-файл обычно занимает на несколько процентов меньше места, чем
`.jar`-файл для того же приложения[@dalvik-internals].

 [^dex]: **D**alvik **EX**ecutable


### Формат DEX ###

При разработке формата DEX главной задачей было устранение дублирования информации.
В каждом DEX-файле содержатся таблицы строк, типов, прототипов методов, описаний полей классов, методов и самих классов.
Это позволяет в дальнейшем ссылаться на конкретную строку, тип, прототип или описание с помощью целочисленного
индекса, являющегося номером строки в соответствующей таблице.

При упаковывании `.class`-файлов в `.jar`-архив данные, содержащиеся в этих файлах, не объединяются.
Поскольку нередко строки и классы (в особенности, системные) упоминаются в нескольких `.class`-файлах
одного приложения, утилита `dx`, предназначенная для создания DEX-файлов, объединяет данные из всех `.class`-файлов,
и таким образом обеспечивается отсутствиие избыточности.


### Устройство виртуальной машины ###

Виртуальная машина загружает определения классов и сопутствующую информацию из одного или нескольких DEX-файлов.[^odex]
Затем она находит класс, имя которого было передано аргументом командной строки, и начинает исполнять
метод `main` этого класса.

 [^odex]: Для достижения наилучшей производительности при установке приложения в телефон все `.dex`-файлы оптимизируются
          и оптимизированные версии кэшируются.
          Такие модифицированные файлы по своему внутреннему формату очень похожи на обычные DEX-файлы, но
          могут содержать нестандартные инструкции, специфичные для
          конкретной реализации виртуальной машины, потому в заголовке таких файлов указывается
          «магическая константа», отличная от используемой в заголовках обычных DEX-файлов, и во избежание путаницы файлы
          сохраняются с расширением `.odex` — **O**ptimized **DEX**.

С точки зрения ВМ метод — это последовательность простейших инструкций, которые следует выполнять по порядку
(но в результате исполнения некоторых инструкций может быть осуществлен переход в другое место программы).
Из одного метода может быть вызван другон метод. Когда вызванный метод завершает работу, управление передается
обратно вызвавшему — как и в большинстве других архитектур такие вложенные вызовы образуют стек.

Программе доступны два способа хранения данных: общая память и набор регистров. Таким образом, Dalvik —
регистровая машина и в этом заключается главное отличие от классической JVM, поскольку JVM оперирует стеком.
Трудно однозначно сказать, какой подход лучше, но исследования в этой области показывают,
что для одного и того же приложения в случае регистровой архитектуры будет исполнено на 47% меньше инструкций[@vm-showdown].
В то же время, объем кода обычно оказывается на 25% больше[@vm-showdown]. При выборе регистровой архитектуры разработчики
Android руководствовались собственными экспериментами, которые показали, что при интерпретации регистрового кода
будет обработано меньше инструкций и совершено меньше обращений к памяти[@dalvik-internals].

Для хранения локальных переменных используются регистры, а данные, общие для нескольких методов, располагаются
в общей памяти (в «куче»). Как и JVM, Dalvik не позволяет осуществлять доступ к памяти напрямую: нет
понятия «указатель» и какого-либо аналога существующей в C и C++ арифметики указателей. Набор инструкций позволяет
создавать новые объекты (`new-instance`), в результате получая _ссылку_ через которую можно работать с полями (`iget`, `iput`, …).

Все инструкции можно условно разделить на несколько классов:

 1. заполнитель `nop`;
 2. работа с регистрами (`move*`, `const*`, …);
 3. управление поток выполнения (`invoke*`, `return*`, `if*`, …);
 4. работа с объектами (`new-instance`, `iget*`, `sget*`, …);
 5. арифметические и битовые операции (`add*`, `sub*`, `neg*`, `not*`).
