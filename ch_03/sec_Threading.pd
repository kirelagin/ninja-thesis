## Многопоточность ##

Изначально все JavaScript-программы были однопоточными. Программы, написанные на языке Java,
нередко используют многопоточность, потому виртуальная машина должна каким-то образом её
эмулировать.

В проектах [@doppio; @dalvik-js] для этого поддерживается список существующих в системе потоков,
которым по очереди предоставляется время для исполнения. Очевидным недостатком такого
подхода является необходимость вручную реализовывать планировщик, хотя в ОС,
в которой запущен браузер, уже есть работающий планировщик. Кроме того, существует
фундаментальное ограничение: поскольку такой код по-прежнему однопоточен с точки
зрения ОС, он в любом случае будет исполняться лишь на одном процессоре (ядре процессора).

В новом стандарте HTML5[@html5] были добавлены _веб-воркеры_ (Web Workers), представляющие
собой, по сути, упрощенные потоки. Классические потоки работают с разделяемой памятью
(shared memory), в то время как веб-воркерам недоступны объекты, созданные в других
воркерах, то есть, в не котором смысле, каждый воркер находится в своем собственном
адресном пространстве.[^1]

Между собой воркеры могут взаимодействовать единственным способом — асинхронно передавая друг
другу сообщения (message passing). При этом содержимое сообщения передается «по значению»,
то есть копируется, что не позволяет передавать ссылки на JavaScript-объекты. Тем не менее,
с помощью передачи сообщений можно имитировать разделяемую память, и именно такой
подход был выбран в данной работе.

Использование веб-воркеров позволяет избежать необходимости вручную осуществлять
диспетчеризацию потоков, а поскольку каждый воркер соответствует реальному потоку
(или процессу) операционной
системы, становится возможным эффективное использование ресурсов многопроцессорных
компьютеров.

 [^1]: Такая упрощенная модель позволяет избежать многих проблем, характерных для
       многопоточных приложений.
