Основные проблемы и их решения
-------------------------------


### Отсутствие документации ### 

Самой неприятно проблемой стало то, что четкой спецификации виртуальной машины Dalvik не существует.
В официальной документации можно найти подробное описание формата DEX и список инструкций виртуальной машины
с кратким описанием каждой, чего, как оказалось, не достаточно для реализации.

Часто основным источником информации о семантике той или иной инструкции служила
спецификация виртуальной машины Java (JVM)[@jvmspec]. С одной стороны, разработчики
виртуальной машины Dalvik не заявляют никакой совместимости с JVM, так что, формально,
эта спецификация не имеет никакого отношения к Dalvik.
С другой стороны, Dalvik существует для того, чтобы исполнять Java-программы,
таким образом, скорее всего, спецификацию JVM можно считать хорошим источником сведений
о требуемом поведении инструкций Dalvik.

Нередко возникали ситуации, когда за разъяснениями приходилось обращаться к исходному
коду, благо исходный код виртуальной машины размещен в свободном доступе.


### Численные типы ###

TODO длинный рассказ о том, что в JS только один вид чисел — 64-битный флоты, потому
приходится аккуратно работать с арифметикой и, что еще веселее, представлять
целые 64-битный числа двумя JS-ными.


### Многопоточность ###

Изначально все JavaScript-программы были однопоточными. Программы, написанные ня языке Java,
нередко используют многопоточность, потому виртуальная машина должна каким-то образом её
эмулировать.

В [@doppio; @dalvik-js] для этого поддерживается список существующих в системе потоков,
которым по очереди предоставляется время для исполнения. Очевидным недостатком такого
подхода является необходимость вручную реализовывать планировщик, хотя в ОС,
в которой запущен браузер, уже есть работающий планировщик. Кроме того, существует
фундаментальное ограничение: поскольку такой код по-прежнему однопоточен с точки
зрения ОС, он в любом случае будет исполняться лишь на одном процессоре (ядре процессора).

В новом стандарте HTML5[@html5] былы добавлены _веб-воркеры_ (Web Workers), представляющие
собой, по сути, упрощенные потоки. Классические потоки работают с разделяемой памятью
(shared memory), в то время как веб-воркерам недоступны объект, созданные в других
воркерах, то есть, в не котором смысле, каждый воркер находится в своем собственном
адресном пространстве. [^1]

Между собой воркеры могут взаимодействовать единственным способом — передавая друг
другу сообщения (message passing). При этом содержимое сообщения передается «по значению»,
то есть копируется, что не позволяет передавать ссылки на JavaScript-объекты. Тем не менее,
с помощью передачи сообщений можно имитировать разделяемую память, и именно такой
подход был выбран в данной работе.

Использование веб-воркеров позволяет избежать необходимости вручную осуществлять
диспетчеризацию, а поскольку каждый воркер соответствует реальному потоку операционной
системы, становится возможным эффективное использование ресурсов многопроцессорных
компьютеров.

 [^1]: Такая упрощенная модель позволяет избежать многих проблем, характерных для
       многопоточных приложений.
