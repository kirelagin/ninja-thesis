Основные проблемы и их решения
-------------------------------


### Отсутствие документации ### 

Самой неприятно проблемой стало то, что четкой спецификации виртуальной машины Dalvik не существует.
В официальной документации можно найти подробное описание формата DEX и список инструкций виртуальной машины
с кратким описанием каждой, чего, как оказалось, не достаточно для реализации.

Часто основным источником информации о семантике той или иной инструкции служила
спецификация виртуальной машины Java (JVM)[@jvmspec]. С одной стороны, разработчики
виртуальной машины Dalvik не заявляют никакой совместимости с JVM, так что, формально,
эта спецификация не имеет никакого отношения к Dalvik.
С другой стороны, Dalvik существует для того, чтобы исполнять Java-программы,
таким образом, скорее всего, спецификацию JVM можно считать хорошим источником сведений
о требуемом поведении инструкций Dalvik.

Нередко возникали ситуации, когда за разъяснениями приходилось обращаться к исходному
коду, благо исходный код виртуальной машины размещен в свободном доступе.


### Численные типы ###

Виртуальная машина Dalvik оперирует четырьмя основными видами чисел:

 * `int` (32-битное целое),
 * `long` (64-битное целое),
 * `float` (32-битное с плавающей точкой)[^ieee],
 * `double` (64-битное с плавающей точкой).

 [^ieee]: Для всех чисел с плавающей точкой используется стандартное представление IEEE 754.

В языке программирования JavaScript существует единственный численный тип — `Number`,
представляющий число с плавающей точкой двойной точности (64 бита). Такой тип полностью
покрывает диапазоны допустимых значений для `int`, `float` и `double`, но не `long`.

В такой ситуации удобнее всего представлять 64-битные целые числа с помощью пары
JavaScript-чисел, в каждом из которых хранятся 32 бита. Таким образом,
64-битное число `c` будет представлено парой чисел `(a, b)`, такой, что
$c = a \cdot 2^{32} + b$. В таком виде над числами сравнительно легко совершать
базовые операции, кроме того, в библиотеке _Closure Library_ такой подход
уже реализован[@gLong].

Несколько более сложная и требущая аккуратности трудность — работа с
двоичными пресдтавлениями чисел. В виртуальной машине для загрузки констант
в регистры используются две операции — `const` и `const-wide` для, соответственно,
32-битных и 64-битных значений. Конкретный тип данных указывается затем для
каждой операции (`add-int`, `div-float`, и т. п.), что приводит к необходимости
хранить в регистрах числа в двоичном представлении и для каждой операции производить
соответствующие преобразования.

При использовании языка C++ такой проблемы нет, поскольку двоичные представления чисел
виртуальной машины Dalvik совпадают с представлениями, используемыми в распространенных
компьютерных архитектурах, потому нет необходимости осуществлять какие-либо явные преобразования.
В случае же JavaScript все такие преобразования должны осуществляться явно.

Самый простой подход заключается в том, чтобы запрограммировать все необходимые алгоритмы
с помощью битовых операций. Однако, в данной работе использован иной подход, более простой в
реализации, основанный на нововведении стандарта HTML5 — типизированных массивах (typed arrays).

Типизированный массив — это, фактически, фрагмент памяти и типизированный интерфейс для доступа
к ней. Особый интерес представляет возможность создать массив данных одного типа, а затем
использовать тот же самый буфер в массиве другого типа. Таким образом, чтобы прочитать из
файла число типа `float`, записанное в двоичном представлении, достаточно совершить
следующие действия:

 1. Считать 32 бита как целое число (`int`).
 2. Создать массив целых 32-битных чисел и записать в него считанное целое число. В этот момент во
    внутреннем буфере массива записано двоичное представление числа с плавающей точкой.
 3. Создать массив чисел с плавающей точкой одинарной точности, использующий тот же буфер.
 4. Считать из нового массива итоговое число (`float`).

Поскольку типизированные массивы используют общепринятые двоичные представления, такая
последовательность действия корректно осуществляет преобразование. Пример кода на языке F\#
приведен в \inlref{листинге}{lst:store-fs}. В \inlref{листинге}{lst:store-js} приведен
аналогичный код на языке JavaScript.


\begin{code}[language=FSharp,label=lst:store-fs,
                   caption={Работа с двоичными представлениями чисел
                            на примере чисел с плавающей точкой одинарной точности (F\#)}]
let loadFloat (binval : int32) : float32 =
    (new Float32Array((new Int32Array([| binval |])).Buffer)).Get(0uL)

let storeFloat (val : float32) : int32 =
    (new Int32Array((new Float32Array([| val |])).Buffer)).Get(0uL)
\end{code}


\begin{code}[language=JavaScript,label=lst:store-js,
                   caption={Работа с двоичными представлениями чисел
                            на примере чисел с плавающей точкой одинарной точности (JavaScript)}]
function loadFloat(binval) {
    return new Float32Array(new Int32Array([binval]).buffer)[0];
}

function storeFloat(val) {
    return new Int32Array(new Float32Array([val]).buffer)[0];
}
\end{code}


Схожим образом реализованы инструкции, осуществляющие конвертацию между примитивными
типами (`int-to-float`, `double-to-long`, и т. п.). Единственное отличие заключается
в том, что также было необходимо правильно обработать все крайние случаи (слишком
большое, либо слишком малое число; NaN, бесконечность и отрицательный ноль в случае
чисел с плавающей точкой).


### Многопоточность ###

Изначально все JavaScript-программы были однопоточными. Программы, написанные на языке Java,
нередко используют многопоточность, потому виртуальная машина должна каким-то образом её
эмулировать.

В проектах [@doppio; @dalvik-js] для этого поддерживается список существующих в системе потоков,
которым по очереди предоставляется время для исполнения. Очевидным недостатком такого
подхода является необходимость вручную реализовывать планировщик, хотя в ОС,
в которой запущен браузер, уже есть работающий планировщик. Кроме того, существует
фундаментальное ограничение: поскольку такой код по-прежнему однопоточен с точки
зрения ОС, он в любом случае будет исполняться лишь на одном процессоре (ядре процессора).

В новом стандарте HTML5[@html5] были добавлены _веб-воркеры_ (Web Workers), представляющие
собой, по сути, упрощенные потоки. Классические потоки работают с разделяемой памятью
(shared memory), в то время как веб-воркерам недоступны объекты, созданные в других
воркерах, то есть, в не котором смысле, каждый воркер находится в своем собственном
адресном пространстве.[^1]

Между собой воркеры могут взаимодействовать единственным способом — асинхронно передавая друг
другу сообщения (message passing). При этом содержимое сообщения передается «по значению»,
то есть копируется, что не позволяет передавать ссылки на JavaScript-объекты. Тем не менее,
с помощью передачи сообщений можно имитировать разделяемую память, и именно такой
подход был выбран в данной работе.

Использование веб-воркеров позволяет избежать необходимости вручную осуществлять
диспетчеризацию, а поскольку каждый воркер соответствует реальному потоку операционной
системы, становится возможным эффективное использование ресурсов многопроцессорных
компьютеров.

 [^1]: Такая упрощенная модель позволяет избежать многих проблем, характерных для
       многопоточных приложений.


### Эмуляция разделяемой памяти с использованием веб-воркеров ###

Поскольку несколько воркеров не могут иметь одно адресное простраство, возникает
необходимость в выделенном воркере, который будет управлять «памятью» все системы.
Роль такого воркера-«менеджера памяти» заключается в том, чтобы хранить все данные
и предоставлять к ним доступ остальным частями по запросу.

В некотором смысле этот воркер-менеджер может рассматриваться как аналог
контроллера оперативной памяти. В классических архитектурах процессор взаимодействует
с контроллером памяти для предоставления программам доступа к хранимым данным, а
в представленной реализации виртуальной машины «процессор» ВМ (функция, отвечающая за
интерпретацию инструкций) взаимодействует с воркером-менеджером.

Взаимодействие построено следующим образом. Если исполняется инструкция, которой
необходим доступ к общей памяти, воркер отправляет сообщение
осуществляющему управление памятью воркеру. Затем выполнение потока приостанавливается
в ожидании ответа. Менеджер памяти обрабатывает пришедший запрос и отправляет
ответ с запрошенными данными (к примеру, если выполняется операция чтения), либо
просто подтверждение выполнения операции (для операций записи). После получения
ответа исполнение потока возобновляется.

Важно отметить, что все сообщения обрабатываются в порядке получения. Тот факт, что
любое производимое потоком изменение в системе, способное оказать влияние на
другие потоки, сопровождается отправкой сообщения менеджеру и приостановлением
потока до получения ответа, гарантирует сохранение требуемого моделью
памяти языка Java порядка _happens-before_.


### Событийная модель и continuation-passing style ###

Выполнение кода в JavaScript управляется _событиями_.
Помимо стека вызовов интерпретатор также поддерживает _очередь событий_ (event queue).
Во время исполнения обработчика события вызовы функций формируют привычный стек,
однако, в отличие от распространенных языков программирования, в которых выход из последней
функции в стеке вызовов приводит к завершению программы, в JavaScript в этот момент начинается
обработка следующего события в очереди.

Ключевым моментом является то, что для начала обработки нового события необходимо, чтобы
текущий обработчик завершился. К примеру, если веб-воркеру требуется запросить какую-либо
информацию у другого воркера, он отправляет ему сообщение (`postMessage`). Функция
`postMessage` сразу же возвращает управление, не дожидаясь ответа от другого воркера —
отправка сообщений происходит _асинхронно_, как только придет сообщение с ответом, в очередь
событий будет добавлено событие `onmessage`. Трудность состоит в том, что текущему обработчику
для продолжения необходима запрошенная информация, но пришедшее сообщение не будет обработано
до тех пор, пока текущий обработчик не завершится.

В такой ситуации удобным оказывается обратиться к парадигме программирования, известной как
_continuation-passing style_ (CPS)[@reynolds]. Основная идея заключается в том, что
каждая функция одним из аргументов принимает «продолжение» — код, который должен
быть выполнен по её завершении. Таким образом, функция в самом конце вызывает своё продолжение
вместо того, чтобы вернуть управление вызвавшей функции.

Из того, что функции самостоятельно вызывают продолжения, следует, что ни одна функция
никогда не возвращается, поскольку возвращение из функции означает, что у неё нет
продолжения, то есть программа завершена. Таким образом, код, расположенный _после_
вызова функции никогда не выполнится, так что естественно требовать, чтобы за
вызовом функции никогда не следовал другой код. Это позволит удобно работать с
асинхронными сообщениями: достаточно реализовать функцию (\autoref{lst:sendrequest}), которая, получив
сообщение для отправки и некоторое продолжение, предназначенное для обработки ответа,
отправляет запрос и настраивает обработчик `onmessage` таким образом, что при получении ответного сообщения будет
запущено продолжение; затем функция возвращает управление, и все функции, находящиеся глубже
в стеке вызовов, также возвращаются, что позволит сработать обработчику события `onmessage`.
Обработчик вызовет сохраненное продолжение и программа продолжит исполнение, как это было
бы в классическом CPS.


\begin{code}[language=Pseudo,label=lst:sendrequest,
                   caption={Функция, отправляющая запрос другому воркеру (псевдокод)}]
send_request = function(request, continuation):
    onmessage =
        function(message):
            continuation(message.data)
    postMessage(request)
\end{code}



### Continuation-passing style и хвостовая рекурсия ###

Continuation-passing style чаще всего используется в функциональных языках программирования.
Отличительной чертой функциональных языков программирования является то, что большинство
компиляторов (интерпретаторов) таких языков обеспечивают оптимизацию хвостовой рекурсии (tail call elimination).

Интерпретатор JavaScript хвостовую рекурсию не оптимизирует, что при активном использовании CPS приводит
к переполнениям стека. Код, использующий продолжения, обычно не содержит циклов, а вместо этого используются
рекурсивные вызовы; в случае виртуальной машины это приводит к необходимости осуществлять
рекурсивный вызов для интерпретации каждой следующей инструкции (\autoref{lst:interpret}), то есть
глубина стека растет довольно быстро.


\begin{code}[language=Pseudo,label=lst:interpret,
                   caption={Функция, интерпретирующая инструкции виртуальной машины при использовании continuation-passing style (псевдокод)}]
interpret = function(index=0, continuation):
    jump = function(new_index):
        interpret(new_index, continuation)
    next = function()
        jump(index + 1)

    switch instructions[index]:
        case ...:
            ...
            next()
        case ...:
            ...
            next()
        case ...:
            ...
            jump(...)
        ...
\end{code}


Для обхода этой проблемы первоначально планировалось использовать
следующий трюк. При каждом вызове функции проверяется, не достигла ли глубина стека некоторой
критической величины; если достигла, то необходимо стек очистить. Похожий подход впервые был
использован в компиляторе языка Scheme под названием Chicken[@chicken]. Комилятор Scheme
работает на низком уровне, что позволяет напрямую манипулировать стековыми кадрами.

В языке JavaScript получить прямой доступ к стеку невозможно, но вместо этого можно использовать
встроенную функцию `setTimeout`, изначально предзназначенную для того, чтобы вызвать
некоторую функцию спустя определенный промежуток времени. Эта функция запускает
таймер, при срабатывании которого в очередь на обработку добавляется событие, обработка которого
приводит к выполнению заданной функции. Если необходимо очистить стек, то вместо очередного
вызова функции осуществляется вызов `setTimeout`, а в качестве аргументов передаются
`0` (что означает «добавить событие в очередь немедленно») и продолжение, которое вызовет
требуемую функцию. Затем текущая функция возвращается.

Так же, как в предыдущем разеделе, передача управления предыдущей функции в стеке
приводит в «раскручиванию» (и, как следствие, очистке) стека вызовов, а затем из очереди
событий извлекается событие, добавленное вызовом `setTimeout`, обработка которого приведет
к возобновлению программы, но уже с пустым стеком.

К сожалению, на практике такой способ проявил себя не очень хорошо. Дело в том, что, к примеру,
в браузере Chromium минимальный интервал для `setTimeout` равен 1\ мс[@chromium-issue888].
Более того, в текущей черновой версии стандарта HTML5 указано, что этот интервал должен составлять
не менее 4\ мс[@html5], так что можно ожидать, что в скором времени и в Chromium, и в других браузерах
минимальный интервал `setTimeout` будет увеличен до требуемого стандартом.
К примеру, если исходная программа на Java выполняла миллион интераций цикла `for`, а стек
«раскручивается» каждые 100 рекурсивных вызовов, то только лишь на «раскручивание», будет затрачено
несколько секунд.

Для тестирования производительности видится разумным проводить сравнение с реальным смартфоном,
посколку это позволит лучше понять, насколько критичным окажется падение производительности
приложений относительно того, с чем пользователи работают в реальной жизни.
В \inlref{таблице}{tbl:unwind} приведено время работы
подобной программы в стандартной реализации Dalvik на смартфоне HTC\ Gratia (HTC\ liberty) и
в веб-браузере Google Chrome 27 с применением описываемого способа очистки стека.


\begin{table}[ht]
\centering
\caption{Сравнение времени работы программы,
         совершающей некоторое число итераций цикла \lstinline!for!,
         в различных реализациях виртуальной машины Dalvik}
\label{tbl:unwind}
\begin{tabular}{|r|l|l|}
\hline
\multirow{2}{*}{Число итераций}     & \multicolumn{2}{c|}{Время работы, мс}                     \\ \cline{2-3}
                                    &   HTC liberty       &   JavaScript      \\ \hline %*
 100                                &   0                 &   8               \\ \hline
 10\,000                            &   2                 &   4\,431          \\ \hline
 100\,000                           &   36                &   44\,426         \\ \hline
 1\,000\,000                        &   390               &   --              \\ \hline
 10\,000\,000                       &   3\,930            &   --              \\
\hline
\end{tabular}
\end{table}


Из приведенных выше расчетов следует, что добавляемый браузером таймаут увеличивает время работы
приблизительно на 4 секунды для программы, выполняющей сто тысяч итераций цикла (сто тысяч итераций,
каждая состоит из четырех инструкций, стек очищается на каждый сотый рекурсивный вызов —
$10^5 \cdot 4 / 100 \cdot 1\text{\ мс} = 4000\text{\ мс}$). Тем не менее, программа выполняется за 44 секунды, на
40 секунд больше.
Профилирование показывает, что 97% всего времени уходит на осуществление служебных операций
движка JavaScript, к которым относятся, в том числе, вызовы функций и работа с очередью событий.

Из изложенного можно сделать два важных вывода:

 1. Предотвращение переполнения стека с помощью `setTimeout` действительно работает, но занимает
    недопустимо много времени.
 2. Использование рекурсивных вызовов вместо циклов оказывает достаточно
    сильное негативное влияние на общую производительность системы.

Наилучшим решением в данной ситуации будет отказ от «чистого» continuation-passing style
и использование императивного цикла в наиболее критичной для производительности части
приложения — в функции, интерпретирующей инструкции виртуальной машины.

TODO: но об этом пойдет рассказ уже в следующем разделе.
