## Оптимизация хвостовой рекурсии с помощью трамплинов ##

Другой классический вариант оптимизации хвостовой рекурсии — использование _трамплинов (trampolines)_.

Для избежания роста глубины стека при рекурсивном вызове функция, вместо того чтобы
непосредственно осуществить вызов, сообщает некоторым образом, какую функцию и
с какими аргументами она желает вызвать, и возвращает управление.

Обычно оптимизированный таким образом код использует специальную стартовую функцию —
трамплин. Для этого программа должна быть записана с использованием
continuation-passing style, что, поскольку в таком случае возвращаемое
значение функции никогда не используется непосредственно для передачи результата
работы, позволяет сообщать, какая функция должна быть вызвана следующей,
с помощью возвращаемого значения.

Продемонстрировать это удобно на классическом примере функции, вычисляющей
факториал переданного числа. На \inlref{листинге}{lst:fact-cps} приведен
псевдокод вычисляющей факториал функции, записанной с использованием CPS.


\begin{code}[language=Pseudo,label=lst:fact-cps,
                   caption={Функция, вычисляющая факториал переданного числа (псевдокод)}]
factorial = function(n, continuation):
    if n == 1:
        continuation(n)
    else:
        new_continuation = function(r):
            continuation(n * r)
        factorial(n - 1, new_continuation)
\end{code}


Для использования трамплина необходимо чтобы функция не вызывала
другие функции самостоятельно, а предоставляла возможность сделать это
вызвавшей её функции-трамплину.
Для этого следует вернуть объект, представляющий собой отложенное вычисление (_thunk_),
являющееся, по сути, продолжением текущей функции.
Измененная соответствующим образом функция вычисления факториала
приведена на \inlref{листинге}{lst:fact-tramp}.


\begin{code}[language=Pseudo,label=lst:fact-tramp,
                   caption={Функция, вычисляющая факториал переданного числа с использованием трамплина (псевдокод)}]
factorial = function(n, continuation):
    if n == 1:
        function(): continuation(n)
    else:
        new_continuation = function(r):
            continuation(n * r)
        function(): factorial(n - 1, new_continuation)
\end{code}


Функция-трамплин приведена на \inlref{листинге}{lst:trampoline}.


\begin{code}[language=Pseudo,label=lst:trampoline,
                   caption={Трамплин (псевдокод)}]
trampoline = function(initial):
    next = initial
    while True:
        next = next()
\end{code}


Легко видеть, что при такой структуре кода глубина стека
никогда не увеличивается более, чем на единицу, следовательно
проблемы с переполнением не возникнет.

Данный подход позволяет избежать дополнительного таймаута, связанного
с особенностью поведения функции `setTimeout`, но по-прежнему обладает
существенными недостатками. В частности, поскольку в случае, когда
рекурсивные вызовы используются вместо императивного цикла,
каждая итерация цикла превращается в рекурсивный вызов,
затраты на огромное число вызовов функций будут весьма существенны.

Помимо этого, использование thunk'ов удваивает общее число
создаваемых функций и их вызовов, что, конечно, тоже нежелательно.

Наилучшим решением в данной ситуации будет отказ от «чистого» continuation-passing style
и использование императивного цикла в наиболее критичной для производительности части
приложения — в функции, интерпретирующей инструкции виртуальной машины.
Это позволит избежать расходов на создание и вызов большого числа функций
по крайней мере пока у потока нет необходимости обмениваться сообщениями с другими потоками,
то есть пока код может быть легко записан без использования продолжений.
