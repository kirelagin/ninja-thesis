## Оптимизация интерпретатора посредством использования императивного цикла ##

Уже было отмечено, что использование циклов совместно с continuation-passing style
не имеет смысла: если в теле цикла осуществляется вызов функции, тело будет выполнено
ровно один раз, поскольку в истинном CPS функции никогда не возвращаются.

Как описано в предыдущих разделах, в данной работе, хоть код и написан так,
будто функции никогда не возвращают значений, на самом деле, возврат из функций
происходит, когда необходимо обработать входящее сообщение. Проблема в том,
что при этом необходимо, чтобы вернулись все функции в стеке вызовов,
поскольку должен завершиться текущий обработчик события. Безусловный цикл
(`while True`), который естественно использовать в интерпретаторе, в этом
случае неприменим, поскольку функция, в которой он содержится, никогда не вернется.

Таким образом, в условии цикла необходимо проверять, ожидает ли выполненный ранее
код ответа на запрос, и если это так, то прерывать цикл, а иначе — интерпретировать
следующую инструкцию виртуальной машины. На \inlref{листинге}{lst:interpret-loop}
приведена измененная соответствующим образом функция `interpret`.


\begin{code}[language=Pseudo,label=lst:interpret-loop,
                   caption={Функция, интерпретирующая инструкции виртуальной машины при использовании continuation-passing style и цикла (псевдокод)}]
index <- 0

interpret = function(continuation):
    unwind <- False

    jump = function(new_index):
        index <- new_index
    next = function()
        jump(index + 1)
        if unwind:
            interpret continuation

    while not unwind:
        switch instructions[index]:
            case ...:
                ...
                next()
            case ...:
                ...
                unwind <- True
                next()
            case ...:
                ...
                jump(...)
            ...
\end{code}
<!-- >>>>> -->


Если в результате выполнения инструкции необходимо «раскрутить» стек для
получения сообщения от другого воркера, будет установлен флаг `unwind` и
цикл прервется. Теперь поведение функции можно описать следующим образом:
«Интерпретировать инструкции в цикле `while` по это возможно, рекурсивный
вызов совершать только если это абсолютно необходимо».

Такой подход положительно сказывается на производительности системы,
поскольку в результате уменьшается число созданных функций и их вызовов.
В тех же ситуациях, когда рекурсивный вызов неизбежен, затраты остаются
прежними.
