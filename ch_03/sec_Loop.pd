## Оптимизация интерпретатора посредством использования императивного цикла ##

Уже было отмечено, что использование циклов совместно с continuation-passing style
не имеет смысла: если в теле цикла осуществляется вызов функции, тело будет выполнено
ровно один раз, поскольку в истинном CPS функции никогда не возвращаются.

Как описано в предыдущих разделах, в данной работе, хоть код и написан так,
будто функции никогда не возвращают значений, на самом деле, возврат из функций
происходит, когда необходимо обработать входящее сообщение. Проблема в том,
что при этом необходимо, чтобы вернулись все функции в стеке вызовов,
поскольку должен завершиться текущий обработчик события. Безусловный цикл
(`while True`), который естественно использовать в интерпретаторе, в этом
случае неприменим, поскольку функция, в которой он содержится, никогда не вернется.

Таким образом, в условии цикла необходимо проверять, ожидает ли выполненный ранее
код ответа на запрос, и если это так, то прерывать цикл, а иначе — интерпретировать
следующую инструкцию виртуальной машины. На \inlref{листинге}{lst:interpret-loop}
приведена измененная соответствующим образом функция `interpret`.


\begin{code}[language=Pseudo,label=lst:interpret-loop,
                   caption={Функция, интерпретирующая инструкции виртуальной машины при использовании continuation-passing style и цикла (псевдокод)}]
index <- 0

interpret = function(continuation):
    unwind <- False

    jump = function(new_index):
        index <- new_index
    next = function()
        jump(index + 1)
        if unwind:
            interpret continuation

    while not unwind:
        switch instructions[index]:
            case ...:
                ...
                next()
            case ...:
                ...
                unwind <- True
                next()
            case ...:
                ...
                jump(...)
            ...
\end{code}
<!-- >>>>> -->


Если в результате выполнения инструкции необходимо «раскрутить» стек для
получения сообщения от другого воркера, будет установлен флаг `unwind` и
цикл прервется. Теперь поведение функции можно описать следующим образом:
«Интерпретировать инструкции в цикле `while` по это возможно, рекурсивный
вызов совершать только если это абсолютно необходимо».

Такой подход положительно сказывается на производительности системы,
поскольку в результате уменьшается число созданных функций и их вызовов.
В тех же ситуациях, когда рекурсивный вызов неизбежен, затраты остаются
прежними.
\inlref{Таблица}{tbl:while} аналогична \inlref{таблице}{tbl:unwind},
с тем отличием, что JavaScript-реализация виртуальной машины использует
цикл `while`, как описано в данном разделе.


\begin{table}[ht]
\centering
\caption{Сравнение времени работы программы,
         совершающей некоторое число итераций цикла \lstinline!for!,
         в различных реализациях виртуальной машины Dalvik}
\label{tbl:while}
\begin{tabular}{|r|l|l|}
\hline
\multirow{2}{*}{Число итераций}     & \multicolumn{2}{c|}{Время работы, мс}                     \\ \cline{2-3}
                                    &   HTC liberty       &   JavaScript      \\ \hline %*
 100                                &   ?                 &   ?               \\ \hline
 10\,000                            &   ?                 &   ?               \\ \hline
 100\,000                           &   ?                 &   ?               \\ \hline
 1\,000\,000                        &   ?                 &   ?               \\ \hline
 10\,000\,000                       &   ?                 &   ?               \\
\hline
\end{tabular}
\end{table}


Измерения показывают, что прирост производительности весьма существенен — производительность выросла
в тысячу раз и в итоге программа исполняется всего в десять раз медленнее, чем на телефоне, что
можно считать достаточно хорошим результатом.

Однако, в таком тесте не используются ни операции работы с памятью, ни какие-либо другие операции,
требующие обмена сообщениями, а именно они, судя по результатам измерений, занимают больше всего времени.
Для оценивания эффективности доступа к памяти была использована программа, вычисляющая сумму
элементов массива. Такая программа на каждой итерации цикла осуществляет чтение памяти,
сопровождающееся обменом сообщениями. Результаты измерений приведены в \inlref{таблице}{tbl:sumarray}.


\begin{table}[ht]
\centering
\caption{Сравнение времени работы программы,
         суммирующей элементы массива,
         в различных реализациях виртуальной машины Dalvik}
\label{tbl:sumarray}
\begin{tabular}{|r|l|l|}
\hline
\multirow{2}{*}{Размер массива}     & \multicolumn{2}{c|}{Время работы, мс}                     \\ \cline{2-3}
                                    &   HTC liberty       &   JavaScript      \\ \hline %*
 100                                &   ?                 &   ?               \\ \hline
 10\,000                            &   ?                 &   ?               \\ \hline
 100\,000                           &   ?                 &   ?               \\ \hline
 1\,000\,000                        &   ?                 &   ?               \\ \hline
 10\,000\,000                       &   ?                 &   ?               \\
\hline
\end{tabular}
\end{table}


Таким образом, программа, постоянно работающая с памятью, замедляется приблизительно в тысячу раз.
Результат можно считать удовлетворительным, поскольку постоянная работа с памятью — это
экстремальный случай, а реальные приложения обычно сочетают в себе осуществление примитивных
операций, выполняющихся в пределах одного потока, с операциями, требующими взаимодействия
между несколькими потоками, потому коэффициент замедления будет несколько меньшим.

Более того, модель памяти Java в некоторых случаях позволяет оптимизировать исполнение
программы посредством сокращения числа обращений к памяти. Реализация подобной
оптимизации, возможно, существенно уменьшит коэффициент замедления.
