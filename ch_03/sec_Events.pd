## Событийная модель и continuation-passing style ##

Часто возникающая необходимость ожидания ответа от другого воркера вносит некоторые особенности
в структуру программы (самой виртуальной машины).

Процесс исполнения JavaScript-программы в целом несколько отличается от исполнения программ,
написанных на других языках. К примеру, у JavaScript-программы есть точка входа:
последовательность инструкций, которая будет выполнена при запуске, но по окончании исполнения
этих инструкций программа не завершается, а приостанавливается, поскольку в дальнейшем
в системе могут происходить события, приводящие к выполнению других фрагментов программы.

Помимо стека вызовов интерпретатор также поддерживает _очередь событий_.
Во время исполнения какого-либо обработчика события вызовы функций формируют привычный стек вызовов,
однако, в отличие от распространенных языков программирования, в которых выход из последней
функции в стеке приводит к завершению программы, в JavaScript в этот момент начинается
обработка следующего события в очереди.

Ключевым моментом является то, что для начала обработки нового события необходимо, чтобы
текущий обработчик завершился. К примеру, если веб-воркеру требуется запросить какую-либо
информацию у другого воркера, он отправляет ему сообщение (`postMessage`). Функция
`postMessage` сразу же возвращает управление, не дожидаясь ответа от другого воркера, —
отправка сообщений происходит _асинхронно_, а как только придет сообщение с ответом, в очередь
событий будет добавлено событие `onmessage`. Трудность состоит в том, что текущему обработчику
для продолжения необходима запрошенная информация, но пришедшее сообщение не будет обработано
до тех пор, пока текущий обработчик не завершится.

В такой ситуации удобным оказывается обратиться к парадигме программирования, известной как
_continuation-passing style_ (CPS)[@reynolds]. Основная идея заключается в том, что
каждая функция одним из аргументов принимает «продолжение» — код, который должен
быть выполнен по её завершении. Таким образом, функция в самом конце вызывает своё продолжение
вместо того, чтобы вернуть управление вызвавшей функции.

Из того, что функции самостоятельно вызывают продолжения, следует, что ни одна функция
никогда не возвращается, поскольку возвращение из функции означает, что у неё нет
продолжения, то есть программа завершена. Таким образом, код, расположенный _после_
вызова функции никогда не выполнится, так что естественно требовать, чтобы за
вызовом функции в тексте программы никогда не следовал другой код. Это позволит удобно работать с
асинхронными сообщениями: достаточно реализовать функцию (\inlref{листинг}{lst:sendrequest}), которая, получив
сообщение для отправки и некоторое продолжение, предназначенное для обработки ответа,
отправляет запрос и настраивает обработчик `onmessage` таким образом, что при получении ответного сообщения будет
запущено продолжение; затем функция возвращает управление, и все функции, находящиеся глубже
в стеке вызовов, также возвращаются, что позволит сработать обработчику события `onmessage`.
Обработчик вызовет сохраненное продолжение и программа продолжит исполнение, как это было
бы в классическом CPS.


\begin{code}[language=Pseudo,label=lst:sendrequest,
                   caption={Функция, отправляющая запрос другому воркеру (псевдокод)}]
send_request = function(request, continuation):
    onmessage =
        function(message):
            continuation(message.data)
    postMessage(request)
\end{code}
