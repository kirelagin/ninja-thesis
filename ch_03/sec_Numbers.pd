## Численные типы ##

Виртуальная машина Dalvik оперирует четырьмя основными видами чисел:

 * `int` (32-битное целое),
 * `long` (64-битное целое),
 * `float` (32-битное с плавающей точкой)[^ieee],
 * `double` (64-битное с плавающей точкой).

 [^ieee]: Для всех чисел с плавающей точкой используется стандартное представление IEEE 754.

В языке программирования JavaScript существует единственный численный тип — `Number`,
представляющий число с плавающей точкой двойной точности (64 бита). Такой тип полностью
покрывает диапазоны допустимых значений для `int`, `float` и `double`, но не `long`.

В такой ситуации удобнее всего представлять 64-битные целые числа с помощью пары
JavaScript-чисел, в каждом из которых хранятся 32 бита. Таким образом,
64-битное число `c` будет представлено парой чисел `(a, b)`, такой, что
$c = a \cdot 2^{32} + b$. В таком виде над числами сравнительно легко совершать
базовые операции, кроме того, в библиотеке _Closure Library_ такой подход
уже реализован[@gLong].

Несколько более сложная и требущая аккуратности задача — работа с
двоичными представлениями чисел. В виртуальной машине для загрузки констант
в регистры используются две операции — `const` и `const-wide` для, соответственно,
32-битных и 64-битных значений. Конкретный тип данных указывается затем для
каждой операции явно (`add-int`, `div-float`, и т. п.), что приводит к необходимости
хранить в регистрах числа в двоичном представлении и для каждой операции производить
соответствующие преобразования.

При использовании языка C++ такой проблемы нет, поскольку двоичные представления чисел
виртуальной машины Dalvik совпадают с представлениями, используемыми в распространенных
компьютерных архитектурах, потому нет необходимости осуществлять какие-либо явные преобразования.
В случае же JavaScript все такие преобразования должны осуществляться явно.

Самый простой подход заключается в том, чтобы запрограммировать все необходимые алгоритмы
с помощью битовых операций. Однако, в данной работе использован иной подход, более простой в
реализации, основанный на нововведении стандарта HTML5 — типизированных массивах (typed arrays).

Типизированный массив — это, фактически, фрагмент памяти и типизированный интерфейс для доступа
к ней. Особый интерес представляет возможность создать массив данных одного типа, а затем
использовать тот же самый буфер в массиве другого типа. Таким образом, чтобы прочитать из
файла число типа `float`, записанное в двоичном представлении, достаточно совершить
следующие действия:

 1. Считать 32 бита как целое число (`int`).
 2. Создать массив целых 32-битных чисел и записать в него считанное целое число. В этот момент во
    внутреннем буфере массива записано двоичное представление числа с плавающей точкой.
 3. Создать массив чисел с плавающей точкой одинарной точности, использующий тот же буфер.
 4. Считать из нового массива итоговое число (`float`).

Поскольку типизированные массивы используют общепринятые двоичные представления, такая
последовательность действия корректно осуществляет преобразование. Пример кода на языке F\#
приведен в \inlref{листинге}{lst:store-fs}. В \inlref{листинге}{lst:store-js} приведен
аналогичный код на языке JavaScript.


\begin{code}[language=FSharp,label=lst:store-fs,
                   caption={Работа с двоичными представлениями чисел
                            на примере чисел с плавающей точкой одинарной точности (F\#)}]
let loadFloat (binval : int32) : float32 =
    (new Float32Array((new Int32Array([| binval |])).Buffer)).Get(0uL)

let storeFloat (val : float32) : int32 =
    (new Int32Array((new Float32Array([| val |])).Buffer)).Get(0uL)
\end{code}


\begin{code}[language=JavaScript,label=lst:store-js,
                   caption={Работа с двоичными представлениями чисел
                            на примере чисел с плавающей точкой одинарной точности (JavaScript)}]
function loadFloat(binval) {
    return new Float32Array(new Int32Array([binval]).buffer)[0];
}

function storeFloat(val) {
    return new Int32Array(new Float32Array([val]).buffer)[0];
}
\end{code}


Схожим образом реализованы инструкции, осуществляющие конвертацию между примитивными
типами (`int-to-float`, `double-to-long`, и т. п.). Единственное отличие заключается
в том, что также было необходимо правильно обработать все крайние случаи (слишком
большое, либо слишком малое число; NaN, бесконечность и отрицательный ноль в случае
чисел с плавающей точкой).

К примеру, для преобразования числа типа `double` в число типа `float` достаточно
записать его в типизированный массив `Float32Array`, а затем прочитать из массива —
все необходимые преобразования будут выполнены движком JavaScript, что избавляет от
необходимости вручную реализовывать алгоритмы IEEE 754.
